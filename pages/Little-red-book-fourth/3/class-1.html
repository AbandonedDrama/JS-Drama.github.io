<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>语言基础 | JS-Drama</title>
    <meta name="generator" content="VuePress 1.8.0">
    <link rel="icon" href="/assets/images/favicon.ico">
    <meta name="description" content="JS-Drama的前端记录">
    
    <link rel="preload" href="/assets/css/0.styles.76891a63.css" as="style"><link rel="preload" href="/assets/js/app.9454abc9.js" as="script"><link rel="preload" href="/assets/js/2.62a85667.js" as="script"><link rel="preload" href="/assets/js/11.4f7dc882.js" as="script"><link rel="prefetch" href="/assets/js/10.26880948.js"><link rel="prefetch" href="/assets/js/12.5477dcee.js"><link rel="prefetch" href="/assets/js/13.26988e73.js"><link rel="prefetch" href="/assets/js/14.8cda783c.js"><link rel="prefetch" href="/assets/js/15.bc5c35ae.js"><link rel="prefetch" href="/assets/js/16.f525dab1.js"><link rel="prefetch" href="/assets/js/3.607988fe.js"><link rel="prefetch" href="/assets/js/4.8496522d.js"><link rel="prefetch" href="/assets/js/5.88d07b8b.js"><link rel="prefetch" href="/assets/js/6.c671543d.js"><link rel="prefetch" href="/assets/js/7.6958cc2c.js"><link rel="prefetch" href="/assets/js/8.38abe476.js"><link rel="prefetch" href="/assets/js/9.5830ce87.js">
    <link rel="stylesheet" href="/assets/css/0.styles.76891a63.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/assets/images/logo.jpg" alt="JS-Drama" class="logo"> <span class="site-name can-hide">JS-Drama</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="红宝书笔记" class="dropdown-title"><span class="title">红宝书笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="红宝书笔记" class="mobile-dropdown-title"><span class="title">红宝书笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Little-red-book-fourth/1/class-1.html" class="nav-link">
  1. 什么是 JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/pages/Little-red-book-fourth/2/class-1.html" class="nav-link">
  2. HTML 中的 JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/pages/Little-red-book-fourth/3/class-1.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  3. 语言基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具类" class="dropdown-title"><span class="title">工具类</span> <span class="arrow down"></span></button> <button type="button" aria-label="工具类" class="mobile-dropdown-title"><span class="title">工具类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Tool/commitizen/class_1.html" class="nav-link">
  git cz
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="杂类-待分类" class="dropdown-title"><span class="title">杂类-待分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="杂类-待分类" class="mobile-dropdown-title"><span class="title">杂类-待分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Miscellaneous/namingThings/class_1.html" class="nav-link">
  函数命名
</a></li><li class="dropdown-item"><!----> <a href="/pages/Miscellaneous/vue+websocket/class_1.html" class="nav-link">
  vue+websocket
</a></li><li class="dropdown-item"><!----> <a href="/pages/Miscellaneous/git/class_1.html" class="nav-link">
  git常用命令
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/JS-Drama/JS-Drama.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">
  首页
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="红宝书笔记" class="dropdown-title"><span class="title">红宝书笔记</span> <span class="arrow down"></span></button> <button type="button" aria-label="红宝书笔记" class="mobile-dropdown-title"><span class="title">红宝书笔记</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Little-red-book-fourth/1/class-1.html" class="nav-link">
  1. 什么是 JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/pages/Little-red-book-fourth/2/class-1.html" class="nav-link">
  2. HTML 中的 JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/pages/Little-red-book-fourth/3/class-1.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  3. 语言基础
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="工具类" class="dropdown-title"><span class="title">工具类</span> <span class="arrow down"></span></button> <button type="button" aria-label="工具类" class="mobile-dropdown-title"><span class="title">工具类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Tool/commitizen/class_1.html" class="nav-link">
  git cz
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="杂类-待分类" class="dropdown-title"><span class="title">杂类-待分类</span> <span class="arrow down"></span></button> <button type="button" aria-label="杂类-待分类" class="mobile-dropdown-title"><span class="title">杂类-待分类</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/Miscellaneous/namingThings/class_1.html" class="nav-link">
  函数命名
</a></li><li class="dropdown-item"><!----> <a href="/pages/Miscellaneous/vue+websocket/class_1.html" class="nav-link">
  vue+websocket
</a></li><li class="dropdown-item"><!----> <a href="/pages/Miscellaneous/git/class_1.html" class="nav-link">
  git常用命令
</a></li></ul></div></div><div class="nav-item"><a href="https://github.com/JS-Drama/JS-Drama.github.io" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>语言基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/Little-red-book-fourth/3/class-1.html#语法" class="sidebar-link">语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#区分大小写" class="sidebar-link">区分大小写</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#标识符" class="sidebar-link">标识符</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#注释" class="sidebar-link">注释</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#严格模式" class="sidebar-link">严格模式</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#语句" class="sidebar-link">语句</a></li></ul></li><li><a href="/pages/Little-red-book-fourth/3/class-1.html#关键字与保留字" class="sidebar-link">关键字与保留字</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/Little-red-book-fourth/3/class-1.html#变量" class="sidebar-link">变量</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#var" class="sidebar-link">var</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#let" class="sidebar-link">let</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#const" class="sidebar-link">const</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#声明风格及最佳实践" class="sidebar-link">声明风格及最佳实践</a></li></ul></li><li><a href="/pages/Little-red-book-fourth/3/class-1.html#数据类型" class="sidebar-link">数据类型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#typeof-操作符" class="sidebar-link">typeof 操作符</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#undefined-类型" class="sidebar-link">Undefined 类型</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#null-类型" class="sidebar-link">Null 类型</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#boolean-类型" class="sidebar-link">Boolean 类型</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#number-类型" class="sidebar-link">Number 类型</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#string-类型" class="sidebar-link">String 类型</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#symbol-类型" class="sidebar-link">Symbol 类型</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#object-类型" class="sidebar-link">Object 类型</a></li></ul></li><li><a href="/pages/Little-red-book-fourth/3/class-1.html#操作符" class="sidebar-link">操作符</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#一元操作符" class="sidebar-link">一元操作符</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#位操作符" class="sidebar-link">位操作符</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#布尔操作符" class="sidebar-link">布尔操作符</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#乘性操作符" class="sidebar-link">乘性操作符</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#指数操作符" class="sidebar-link">指数操作符</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#加性操作符" class="sidebar-link">加性操作符</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#关系操作符" class="sidebar-link">关系操作符</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#相等操作符" class="sidebar-link">相等操作符</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#条件操作符" class="sidebar-link">条件操作符</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#赋值操作符" class="sidebar-link">赋值操作符</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#逗号操作符" class="sidebar-link">逗号操作符</a></li></ul></li><li><a href="/pages/Little-red-book-fourth/3/class-1.html#语句-2" class="sidebar-link">语句</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#if语句" class="sidebar-link">if语句</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#do-while语句" class="sidebar-link">do-while语句</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#while语句" class="sidebar-link">while语句</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#for语句" class="sidebar-link">for语句</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#for-in语句" class="sidebar-link">for-in语句</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#for-of语句" class="sidebar-link">for-of语句</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#标签语句" class="sidebar-link">标签语句</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#break和continue语句" class="sidebar-link">break和continue语句</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#with语句" class="sidebar-link">with语句</a></li><li class="sidebar-sub-header"><a href="/pages/Little-red-book-fourth/3/class-1.html#switch语句" class="sidebar-link">switch语句</a></li></ul></li><li><a href="/pages/Little-red-book-fourth/3/class-1.html#函数" class="sidebar-link">函数</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/pages/Little-red-book-fourth/3/class-1.html#小结" class="sidebar-link">小结</a><ul class="sidebar-sub-headers"></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="语言基础"><a href="#语言基础" class="header-anchor">#</a> 语言基础</h1> <blockquote><p>任何语言的核心所描述的都是这门语言在最基本的层面上如何工作，涉及语法、操作符、数据类型 以及内置功能，在此基础之上才可以构建复杂的解决方案。如前所述，ECMA-262 以一个名为 ECMAScript 的伪语言的形式，定义了 JavaScript 的所有这些方面。</p> <p>ECMA-262 第 5 版(ES5)定义的 ECMAScript，是目前为止实现得最为广泛(即受浏览器支持最好) 的一个版本。第 6 版(ES6)在浏览器中的实现(即受支持)程度次之。到 2017 年底，大多数主流浏览器几乎或全部实现了这一版的规范。为此，本章接下来的内容主要基于 ECMAScript 第 6 版。</p></blockquote> <h2 id="语法"><a href="#语法" class="header-anchor">#</a> 语法</h2> <p>ECMAScript 的语法很大程度上借鉴了 C 语言和其他类 C 语言，如 Java 和 Perl。熟悉这些语言的开发者，应该很容易理解 ECMAScript 宽松的语法。</p> <h3 id="区分大小写"><a href="#区分大小写" class="header-anchor">#</a> 区分大小写</h3> <p>ECMAScript 中一切都区分大小写，无论是变量、函数名还是操作符。变量 test 和 Test 是两个完全不同的变量。</p> <h3 id="标识符"><a href="#标识符" class="header-anchor">#</a> 标识符</h3> <blockquote><p>就是变量、函数或函数参数的名称</p></blockquote> <ol><li>第一个字符必须是一个字母、下划线或美元符号</li> <li>剩下的可以使字母、下划线、美元符号或数字</li></ol> <p>按照惯例，ECMAScript 标识符使用驼峰大小写形式</p> <h3 id="注释"><a href="#注释" class="header-anchor">#</a> 注释</h3> <p>ECMAScript 采用 C 语言风格的注释，包括单行注释和块注释。单行注释以两个斜杠字符开头，如:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">// 单行注释</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>块注释以一个斜杠和一个星号(/*)开头，以它们的反向组合(*/)结尾，如:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">/* 这是多行
注释 */</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="严格模式"><a href="#严格模式" class="header-anchor">#</a> 严格模式</h3> <p>ECMAScript 5 增加了严格模式(strict mode)的概念。严格模式是一种不同的 JavaScript 解析和执 行模型，ECMAScript 3 的一些不规范写法在这种模式下会被处理，对于不安全的活动将抛出错误。要对 整个脚本启用严格模式，在脚本开头加上这一行:</p> <p><code>&quot;use strict&quot;;</code></p> <p>虽然看起来像个没有赋值给任何变量的字符串，但它其实是一个预处理指令。任何支持的 JavaScript 引擎看到它都会切换到严格模式。选择这种语法形式的目的是不破坏 ECMAScript 3 语法。</p> <p>也可以单独指定一个函数在严格模式下执行，只要把这个预处理指令放到函数体开头即可:</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token string">'use strict'</span><span class="token punctuation">;</span>
  <span class="token comment">// 函数体</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>严格模式会影响 JavaScript 执行的很多方面，所有现代浏览器都支持严格模式。</p> <h3 id="语句"><a href="#语句" class="header-anchor">#</a> 语句</h3> <p>ECMAScript 中的语句以分号结尾。省略分号意味着解析器不确定语句在哪里结尾，即时语句末尾的分号不是必需的，也应该加上。避免在代码压缩时造成错误的解析，加分号有助于提升性能，因为解析器会尝试在合适的位置补上分号以纠正语法错误。</p> <h2 id="关键字与保留字"><a href="#关键字与保留字" class="header-anchor">#</a> 关键字与保留字</h2> <table><thead><tr><th>ECMA-262 第 6 版-目前</th> <th>ECMA-262 第 6 版-未来</th></tr></thead> <tbody><tr><td>break、do、in、typeof、case、else、instanceof、var、catch、export、new、void、class、extends、return、while、const、finally、super、with、continue、for、switch、yield、debugger、function、this、default、if、throw、delete、import、try</td> <td>enum、implements、package、public、interface、protected、static、let、provate、await</td></tr></tbody></table> <blockquote><p>这些词汇不能用作标识符，但现在还可以用作对象的属性名。一般来说，最好还是不要使用关键字</p> <p>和保留字作为标识符和属性名，以确保兼容过去和未来的 ECMAScript 版本。</p></blockquote> <h2 id="变量"><a href="#变量" class="header-anchor">#</a> 变量</h2> <p>ECMAScript 变量是松散类型的，意思是变量可以用于保存任何类型的数据。每个变量只不过是一个用于保存任意值的命名占位符。有 3 个关键字可以声明变量:var、const 和 let。其中，var 在 ECMAScript 的所有版本中都可以使用，而 const 和 let 只能在 ECMAScript 6 及更晚的版本中使用。</p> <h3 id="var"><a href="#var" class="header-anchor">#</a> var</h3> <p>var 存在声明提升以及污染全局（成为 Window 对象的属性）的问题，建议使用 let 与 const 代替。</p> <h3 id="let"><a href="#let" class="header-anchor">#</a> let</h3> <p>let 声明的范围是块作用域</p> <p>let 不予许冗余声明</p> <p>let 不存在声明提升</p> <p>let 存在暂时性死区（temporal dead zone）</p> <p>let 不可以条件声明</p> <blockquote><p>不能使用 let 进行条件式声明是件好事，因为条件声明是一种反模式，它让程序变 得更难理解。如果你发现自己在使用这个模式，那一定有更好的替代方式。</p></blockquote> <p>let 与 for 循环</p> <blockquote><p>JavaScript 引擎在后台会为每个迭代循环声明一个新的迭代变量。 每个 setTimeout 引用的都是不同的变量实例，所以 console.log 输出的是我们期望的值，也就是循环执行过程中每个迭代变量的值。</p> <p>这种每次迭代声明一个独立变量实例的行为适用于所有风格的 for 循环，包括 for-in 和 for-of 循环。</p></blockquote> <h3 id="const"><a href="#const" class="header-anchor">#</a> const</h3> <blockquote><p>const 的行为与 let 基本相同，唯一一个重要的区别是用它声明变量时必须同时初始化变量，且尝试修改 const 声明的变量会导致运行时错误。</p></blockquote> <p>const 声明的限制只适用于它指向的变量的引用。如果 const 变量引用的是一个对象， 那么修改这个对象内部的属性并不违反 const 的限制。</p> <h3 id="声明风格及最佳实践"><a href="#声明风格及最佳实践" class="header-anchor">#</a> 声明风格及最佳实践</h3> <blockquote><p>ECMAScript 6 增加 let 和 const 从客观上为这门语言更精确地声明作用域和语义提供了更好的支 11 持。行为怪异的 var 所造成的各种问题，已经让 JavaScript 社区为之苦恼了很多年。随着这两个新关键字的出现，新的有助于提升代码质量的最佳实践也逐渐显现。</p></blockquote> <p>1.不使用 var</p> <p>有了 let 和 const，大多数开发者会发现自己不再需要 var 了。限制自己只使用 let 和 const 有助于提升代码质量，因为变量有了明确的作用域、声明位置，以及不变的值。</p> <p>2.const 优先，let 次之</p> <p>使用 const 声明可以让浏览器运行时强制保持变量不变，也可以让静态代码分析工具提前发现不合法的赋值操作。因此，很多开发者认为应该优先使用 const 来声明变量，只在提前知道未来会有修 改时，再使用 let。这样可以让开发者更有信心地推断某些变量的值永远不会变，同时也能迅速发现因意外赋值导致的非预期行为。</p> <h2 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h2> <p>ECMAScript 有 6 种简单数据类型(也称为原始类型):Undefined、Null、Boolean、Number、String 和 Symbol。Symbol(符号)是 ECMAScript 6 新增的。还有一种复杂数据类型叫 Object(对象)。Object 是一种无序名值对的集合。因为在 ECMAScript 中不能定义自己的数据类型，所有值都可以用上述 7 种数据类型之一来表示。只有 7 种数据类型似乎不足以表示全部数据。但 ECMAScript 的数据类型很灵活，一种数据类型可以当作多种数据类型来使用。</p> <h3 id="typeof-操作符"><a href="#typeof-操作符" class="header-anchor">#</a> typeof 操作符</h3> <ul><li>&quot;undefined&quot;表示值未定义;</li> <li>&quot;boolean&quot;表示值为布尔值;</li> <li>&quot;string&quot;表示值为字符串;</li> <li>&quot;number&quot;表示值为数值;</li> <li>&quot;object&quot;表示值为对象(而不是函数)或 null;</li> <li>&quot;function&quot;表示值为函数;</li> <li>&quot;symbol&quot;表示值为符号。</li></ul> <blockquote><p>特殊值 null 被认为是一个对空对象的引用。</p> <p>严格来讲，函数在 ECMAScript 中被认为是对象，并不代表一种数据类型。可是，函数也有自己特殊的属性。为此，就有必要通过 typeof 操作符来区分函数和其他对象。</p> <p>无论是声明（为赋值）还是未声明，typeof 返回的都是字符串&quot;undefined&quot;。逻辑上讲这是对的，因为虽然严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。</p></blockquote> <h4 id="假值-额外提前补充"><a href="#假值-额外提前补充" class="header-anchor">#</a> 假值（额外提前补充）</h4> <p>falsy 值 (虚值) 是在 Boolean 上下文中认定为 false 的值。</p> <p>JavaScript 在需要用到布尔类型值的上下文中使用强制类型转换(Type Conversion )将值转换为布尔值，例如条件语句和循环语句。</p> <p>在 JavaScript 中只有 8 个 falsy 值。</p> <table><thead><tr><th>false</th> <th>关键字</th></tr></thead> <tbody><tr><td>0</td> <td>数值</td></tr> <tr><td>-0</td> <td>数值</td></tr> <tr><td>0n</td> <td>当 BigInt 作为布尔值使用时, 遵从其作为数值的规则. 0n 是 falsy 值.</td></tr> <tr><td>&quot;&quot;、''</td> <td>这是一个空字符串 (字符串的长度为零). JavaScript 中的字符串可用双引号 <code>**&quot;&quot;**</code>, 单引号 <code>''</code>, 或 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener noreferrer">模板字面量<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <strong>``</strong> 定义。</td></tr> <tr><td>null</td> <td>缺省值</td></tr> <tr><td>undefined</td> <td>原始值</td></tr> <tr><td>NaN</td> <td>非数值</td></tr></tbody></table> <h3 id="undefined-类型"><a href="#undefined-类型" class="header-anchor">#</a> Undefined 类型</h3> <p>Undefined 类型只有一个值，就是特殊值 undefined。当使用 var 或 let 声明了变量但没有初始化时，就相当于给变量赋予了 undefined 值。</p> <p>一般来说，永远不用显式地给某个变量设置 undefined 值。字面值 undefined 主要用于比较，而且在 ECMA-262 第 3 版之前是不存在的。增加这个特殊值的目的就是为了正式明确空对象指针(null)和未初始化变量的区别。</p> <p>即使未初始化的变量会被自动赋予 undefined 值，但我们仍然建议在声明变量的同时进行初始化。这样，当 typeof 返回&quot;undefined&quot;时，你就会知道那是因为给定的变量尚未声明，而不是声明了但未初始化。</p> <h3 id="null-类型"><a href="#null-类型" class="header-anchor">#</a> Null 类型</h3> <p>Null 类型同样只有一个值，即特殊值 null。逻辑上讲，null 值表示一个空对象指针，这也是给 typeof 传一个 null 会返回&quot;object&quot;的原因。</p> <p>在定义将来要保存对象值的变量时，建议使用 null 来初始化，不要使用其他值。这样，只要检查 这个变量的值是不是 null 就可以知道这个变量是否在后来被重新赋予了一个对象的引用。</p> <p>undefined 值是由 null 值派生而来的，因此 ECMA-262 将它们定义为表面上相等。</p> <h3 id="boolean-类型"><a href="#boolean-类型" class="header-anchor">#</a> Boolean 类型</h3> <p>Boolean(布尔值)类型是 ECMAScript 中使用最频繁的类型之一，有两个字面值:true 和 false。这两个布尔值不同于数值，因此 true 不等于 1，false 不等于 0。</p> <h3 id="number-类型"><a href="#number-类型" class="header-anchor">#</a> Number 类型</h3> <p>ECMAScript 中最有意思的数据类型或许就是 Number 了。Number 类型使用 IEEE 754 格式表示整数和浮点值(在某些语言中也叫双精度值)。不同的数值类型相应地也有不同的数值字面量格式。</p> <blockquote><p>由于 JavaScript 保存数值的方式，实际中可能存在正零(+0)和负零(-0)。正零和 负零在所有情况下都被认为是等同的，</p></blockquote> <h4 id="浮点值"><a href="#浮点值" class="header-anchor">#</a> 浮点值</h4> <p>存储浮点值使用的内存空间是存储整数值的两倍，所以 ECMAScript 总是想方设法把值转换为整数。在小数点后面没有数字的情况下，数值就会变成整数。类似地，如果数值本身就是整数，只是小数点后面跟着 0(如 1.0)，那它也会被转换为整数。</p> <p>在检测两个数值之和是否等于 0.3。如果两个数值分别是 0.05 和 0.25，或者 0.15 和 0.15，那没问题。但如果是 0.1 和 0.2，如前所述，测试将失败。因此永远不要测试某个特定的浮点值。</p> <blockquote><p>之所以存在这种舍入错误，是因为使用了 IEEE754 数值，这种错误并非 ECMAScript 所独有。其他使用相同格式的语言也有这个问题。</p></blockquote> <h4 id="值的范围"><a href="#值的范围" class="header-anchor">#</a> 值的范围</h4> <p>ECMAScript 可以表示的最小数值保存在 Number.MIN_VALUE 中，最大数值保存在 Number.MAX_VALUE 中，多数浏览器中是 1.797 693 134 862 315 7e+308。</p> <p>结果超出了 JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的 Infinity(无穷)值。</p> <p>如果要确定一个值是否是限制范围内，可以使用 isFinite()函数。</p> <h4 id="type-value-variable-是什么-额外补充"><a href="#type-value-variable-是什么-额外补充" class="header-anchor">#</a> type / value / variable 是什么（额外补充）</h4> <p>在 JavaScript 中，value 一共有七种 type</p> <ol><li>null</li> <li>undefined</li> <li>boolean</li> <li>number</li> <li>string</li> <li>object</li> <li>symbol (ES6 新增)</li></ol> <p>那么，variable 是什么呢？就是我们平时 <code>var</code> 之后的声明的那个东西。</p> <p>type, value, variable 之间的关系可以这么说：variable 是存放 value 的容器，而 value 是有着 type 概念的，但是容器 variable 是没有 type 的概念的，举个例子</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>容器 variable <code>a</code> 装着 value <code>'foo'</code>, value <code>'foo'</code> 的 type 是 string</p> <h4 id="nan"><a href="#nan" class="header-anchor">#</a> NaN</h4> <p>有一个特殊的数值叫 NaN，意思是“不是数值”(Not a Number)，用于表示本来要返回数值的操作失败了(而不是抛出错误)。</p> <blockquote><p>用 0 除任意数值在其他语言中通常都会导致错误，从而中止代码执 12 行。但在 ECMAScript 中，0、+0 或-0 相除会返回 NaN。</p></blockquote> <p>如果要确定一个数值是否是特殊值 NaN，可以使用 isNaN()函数</p> <blockquote><p>isNaN()可以用于测试对象。此时，首先会调用对象的 valueOf()方法，然后再确定返回的值是否可以转换为数值。如果不能，再调用 toString()方法，并测试其返回值。这通常是 ECMAScript 内置函数和操作符的工作方式。</p></blockquote> <h4 id="数值转换"><a href="#数值转换" class="header-anchor">#</a> 数值转换</h4> <p>有 3 个函数可以将非数值转换为数值:Number()、parseInt()和 parseFloat()。Number()是转型函数，可用于任何数据类型。后两个函数主要用于将字符串转换为数值。</p> <h5 id="number-函数"><a href="#number-函数" class="header-anchor">#</a> Number()函数</h5> <table><thead><tr><th>布尔值</th> <th>true=1，false=0</th></tr></thead> <tbody><tr><td>数值</td> <td>直接返回</td></tr> <tr><td>null</td> <td>0</td></tr> <tr><td>undefined</td> <td>NaN</td></tr> <tr><td>字符串</td> <td>&gt;如果字符串包含数值字符，包括数值字符前面带加、减号的情况，则转换为一个十进制数值。 因此，Number(&quot;1&quot;)返回 1，Number(&quot;123&quot;)返回 123，Number(&quot;011&quot;)返回 11(忽略前面的零)。<br>&gt;如果字符串包含有效的浮点值格式如&quot;1.1&quot;，则会转换为相应的浮点值(同样，忽略前面的零)。<br>&gt;如果字符串包含有效的十六进制格式如&quot;0xf&quot;，则会转换为与该十六进制值对应的十进制整数值。<br>&gt;如果是空字符串(不包含字符)，则返回 0。<br>&gt;如果字符串包含除上述情况之外的其他字符，则返回 NaN。</td></tr> <tr><td>对象</td> <td>调用 valueOf()方法，并按照上述规则转换返回的值。如果转换结果是 NaN，则调用 toString()方法，再按照转换字符串的规则转换。</td></tr></tbody></table> <h5 id="parseint-函数"><a href="#parseint-函数" class="header-anchor">#</a> parseInt()函数</h5> <p>parseInt()函数更专注于字符串是否包含数值模式。字符串最前面的空格会被忽略，从第一个非空格字符开始转换。如果第一个字符不是数值字符、加号或减号，parseInt()立即返回 NaN。这意味着空字符串也会返回 NaN(这一点跟 Number()不一样，它返回 0)。如果第一个字符是数值字符、加号或减号，则继续依次检测每个字符，直到字符串末尾，或碰到非数值字符。</p> <p>不同的数值格式很容易混淆，因此 parseInt()也接收第二个参数，用于指定底数(进制数)。</p> <p>不传底数参数相当于让 parseInt()自己决定如何解析，所以为避免解析出错，建议始终传给它第二个参数。</p> <h5 id="parsefloat-函数"><a href="#parsefloat-函数" class="header-anchor">#</a> parseFloat()函数</h5> <p>跟parseInt()函数类似，都是从0位开始，解析到字符串末尾或者解析到一个无效的浮点数值字符为止。这意味着第一次出现的小数点是有效的，但第二次出现的小数点就无效了，此时字符串的剩余字符都会被忽略。</p> <p>parseFloat()只解析十进制值，因此不能指定底数。</p> <h3 id="string-类型"><a href="#string-类型" class="header-anchor">#</a> String 类型</h3> <blockquote><p>String(字符串)数据类型表示零或多个 16 位 Unicode 字符序列。字符串可以使用双引号(&quot;)、 单引号(')或反引号(`)标示。</p></blockquote> <h4 id="字符字面量"><a href="#字符字面量" class="header-anchor">#</a> 字符字面量</h4> <p>字符串数据类型包含一些字符字面量，用于表示非打印字符或有其他用途的字符</p> <table><thead><tr><th>字面量</th> <th>含义</th></tr></thead> <tbody><tr><td>\n</td> <td>换行</td></tr> <tr><td>\t</td> <td>制表</td></tr> <tr><td>\b</td> <td>退格</td></tr> <tr><td>\r</td> <td>回车</td></tr> <tr><td>\f</td> <td>换行</td></tr> <tr><td>\</td> <td>反斜杠</td></tr> <tr><td>\'</td> <td>单引号</td></tr> <tr><td>\&quot;</td> <td>双引号</td></tr> <tr><td>\`</td> <td>反引号</td></tr> <tr><td>\xnn</td> <td>以十六进制编码nn表示的字符</td></tr> <tr><td>\unnn</td> <td>以十六进制编码nnn表示的Unicode字符</td></tr></tbody></table> <p>这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释</p> <blockquote><p>但是通过String.length获取包含双字节字符时，返回值不是准备的字符数</p></blockquote> <h4 id="字符串的特点"><a href="#字符串的特点" class="header-anchor">#</a> 字符串的特点</h4> <p>ECMAScript 中的字符串是不可变的(immutable)，意思是一旦创建，它们的值就不能变了。要修改某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量。</p> <p>创建字符串时分配的内存空间是固定的，当两个字符串组合时会先销毁两个字符串再创建一个可以容纳两个字符串组合后的固定空间。</p> <h4 id="转换为字符串"><a href="#转换为字符串" class="header-anchor">#</a> 转换为字符串</h4> <p>有两种方式把一个值转换为字符串。首先是使用几乎所有值都有的 toString()方法。这个方法唯一的用途就是返回当前值的字符串等价物。</p> <p>toString()方法可见于数值、布尔值、对象和字符串值。</p> <p>null 和 undefined 值没有 toString()方法。</p> <p>字符串值也有 toString()方法，该方法只是简单地返回自身的一个副本。</p> <p>toString()可以接受一个底参，默认为10，可以通过传入底参转换（二、八、十六进制）</p> <p>如果你不确定一个值是不是 null 或 undefined，可以使用 String()转型函数，它始终会返回表示相应类型值的字符串。</p> <p>String()函数遵循如下规则。</p> <ul><li>如果值有 toString()方法，则调用该方法(不传参数)并返回结果。</li> <li>如果值是 null，返回&quot;null&quot;。</li> <li>如果值是 undefined，返回&quot;undefined&quot;。</li></ul> <h4 id="模板字面量"><a href="#模板字面量" class="header-anchor">#</a> 模板字面量</h4> <p>ECMAScript 6 新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，模板字面量 保留换行字符，可以跨行定义字符串。</p> <h4 id="字符串插值"><a href="#字符串插值" class="header-anchor">#</a> 字符串插值</h4> <p>模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个值。技术上讲，模板字面量不是字符串，而是<strong>一种特殊的 JavaScript 句法表达式</strong>，只不过求值后得到的是字符串。模板字面量在定义时立即求值并转换为字符串实例，任何插入的变量也会从它们最接近的作用域中取值。</p> <p>字符串插值通过在<code>${}</code>中使用一个 JavaScript 表达式实现。</p> <p>所有插入的值都会使用 toString()强制转型为字符串，而且任何 JavaScript 表达式都可以用于插值。嵌套的模板字符串无须转义.</p> <h4 id="模板字面量标签函数"><a href="#模板字面量标签函数" class="header-anchor">#</a> 模板字面量标签函数</h4> <p>模板字面量也支持定义<strong>标签函数(tag function)</strong>，而通过标签函数可以自定义插值行为。标签函数会接收被插值记号分隔后的模板和对每个表达式求值的结果。</p> <p>标签函数本身是一个常规函数，通过前缀到模板字面量来应用自定义行为。</p> <h4 id="原始字符串"><a href="#原始字符串" class="header-anchor">#</a> 原始字符串</h4> <p>使用模板字面量也可以直接获取原始的模板字面量内容(如换行符或 Unicode 字符)，而不是被转 换后的字符表示。为此，可以使用默认的 String.raw 标签函数。</p> <h3 id="symbol-类型"><a href="#symbol-类型" class="header-anchor">#</a> Symbol 类型</h3> <p>Symbol(符号)是 ECMAScript 6 新增的数据类型。</p> <p>符号是原始值，且符号实例是唯一、不可变的。符号的用途是<strong>确保对象属性使用唯一标识符，不会发生属性冲突的危险</strong>。</p> <p>尽管听起来跟私有属性有点类似，但符号并不是为了提供私有属性的行为才增加的(尤其是因为Object API 提供了方法，可以更方便地发现符号属性)。相反，符号就是用来创建唯一记号，进而用作非字符串形式的对象属性。</p> <h4 id="符号的基本用法"><a href="#符号的基本用法" class="header-anchor">#</a> 符号的基本用法</h4> <p>符号需要使用 Symbol()函数初始化。因为符号本身是原始类型，所以 typeof 操作符对符号返回symbol。</p> <p>调用 Symbol()函数时，也可以传入一个字符串参数作为对符号的描述(description)，将来可以通过这个字符串来调试代码。但是，这个字符串参数与符号定义或标识完全无关。</p> <p>符号没有字面量语法，这也是它们发挥作用的关键。按照规范，你只要创建 Symbol()实例并将其用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。</p> <p>最重要的是，Symbol()函数不能与 new 关键字一起作为构造函数使用。这样做是为了避免创建符号包装对象，像使用 Boolean、String 或 Number 那样，它们都支持构造函数且可用于初始化包含原始值的包装对象。</p> <p>如果你确实想使用符号包装对象，可以借用 Object()函数：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> mySymbol <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> myWrappedSymbol <span class="token operator">=</span> <span class="token function">Object</span><span class="token punctuation">(</span>mySymbol<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> myWrappedSymbol<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;object&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h4 id="使用全局符号注册表"><a href="#使用全局符号注册表" class="header-anchor">#</a> 使用全局符号注册表</h4> <p>如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册 表中创建并重用符号。</p> <p>Symbol.for()方法：</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> fooGlobalSymbol <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> fooGlobalSymbol<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// symbol</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。</p> <p>即使采用相同的符号描述，在全局注册表中定义的符号跟使用 Symbol()定义的符号也并不等同。</p> <p>全局注册表中的符号必须使用字符串键来创建，因此作为参数传给 Symbol.for()的任何值都会被转换为字符串。此外，注册表中使用的键同时也会被用作符号描述。</p> <p>Symbol.keyFor()方法：</p> <p>用来查询全局注册表，方法接收符号，返回该全局符号对应的字符串键，相反查询的不是全局符号，返回undefined。</p> <p>如果传给Symbol.keyFor(123)，则抛出TypeError。</p> <h4 id="使用符号做为属性"><a href="#使用符号做为属性" class="header-anchor">#</a> 使用符号做为属性</h4> <p>凡是可以使用字符串或数值作为属性的地方，都可以使用符号。这就包括了对象字面量属性和Object.defineProperty()/Object.defineProperties()定义的属性。对象字面量只能在计算属性语法中使用符号作为属性。</p> <p>类似于 Object.getOwnPropertyNames()返回对象实例的常规属性数组，Object.getOwnPropertySymbols()返回对象实例的符号属性数组。这两个方法的返回值彼此互斥。Object.getOwnPropertyDescriptors()会返回同时包含常规和符号属性描述符的对象。Reflect.ownKeys()会返回两种类型的键。</p> <p>因为符号属性是对内存中符号的一个引用，所以直接创建并用作属性的符号不会丢失。但是，如果 没有显式地保存对这些属性的引用，那么必须遍历对象的所有符号属性才能找到相应的属性键。</p> <h4 id="常用内置符号"><a href="#常用内置符号" class="header-anchor">#</a> 常用内置符号</h4> <p>ECMAScript 6 也引入了一批常用内置符号(well-known symbol)，用于暴露语言内部行为，开发者 可以直接访问、重写或模拟这些行为。这些内置符号都以 Symbol 工厂函数字符串属性的形式存在。</p> <p>这些内置符号最重要的用途之一是重新定义它们，从而改变原生结构的行为。比如，我们知道for-of 循环会在相关对象上使用 Symbol.iterator 属性，那么就可以通过在自定义对象上重新定义Symbol.iterator 的值，来改变 for-of 在迭代该对象时的行为。</p> <p>这些内置符号也没有什么特别之处，它们就是全局函数 Symbol 的普通字符串属性，指向一个符号的实例。所有内置符号属性都是不可写、不可枚举、不可配置的。</p> <h4 id="symbol-iterator"><a href="#symbol-iterator" class="header-anchor">#</a> Symbol.iterator</h4> <blockquote><p>这个符号作为一个属性表示：一个方法，该方法返回对象默认的迭代器。 由 for-of 语句使用。</p></blockquote> <p>表示实现迭代器 API 的函数</p> <h4 id="symbol-asynciterator"><a href="#symbol-asynciterator" class="header-anchor">#</a> Symbol.asyncIterator</h4> <blockquote><p>这个符号作为一个属性表示：一个方法，该方法返回对象默认的 AsyncIterator。 由 for-await-of 语句使用。</p></blockquote> <p>表示实现异步迭代器 API 的函数，ES2018规范定义</p> <h4 id="symbol-hasinstance"><a href="#symbol-hasinstance" class="header-anchor">#</a> Symbol.hasInstance</h4> <blockquote><p>这个符号作为一个属性表示：一个方法，该方法决定一个构造器对象是否认可一个对象是它的实例。由 instanceof 操作符使用。</p></blockquote> <p>instanceof 操作符可以用来确定一个对象实例的原型链上是否有原型。</p> <h4 id="symbol-isconcatspreadable"><a href="#symbol-isconcatspreadable" class="header-anchor">#</a> Symbol.isConcatSpreadable</h4> <blockquote><p>这个符号作为一个属性表示：一个布尔值，如果是 true，则意味着对象应 该用 Array.prototype.concat()打平其数组元素。</p></blockquote> <p>这个符号表示一个数组是否可以打平，其他不是类数组对象的对象设置为true会被忽略</p> <h4 id="symbol-match"><a href="#symbol-match" class="header-anchor">#</a> Symbol.match</h4> <blockquote><p>这个符号作为一个属性表示：一个正则表达式方法，该方法用正则表达式 去匹配字符串。由 String.prototype.match()方法使用。</p></blockquote> <p>String.prototype.match()方法会使用以 Symbol.match 为键的函数来对正则表达式求值</p> <h4 id="symbol-replace"><a href="#symbol-replace" class="header-anchor">#</a> Symbol.replace</h4> <blockquote><p>这个符号作为一个属性表示：一个正则表达式方法，该方法替换一个字符串中匹配的子串。由 String.prototype.replace()方法使用。</p></blockquote> <p>String.prototype.replace()方法会使用以Symbol.replace 为键的函数来对正则表达式求值</p> <h4 id="symbol-search"><a href="#symbol-search" class="header-anchor">#</a> Symbol.search</h4> <blockquote><p>这个符号作为一个属性表示：一个正则表达式方法，该方法返回字符串中 匹配正则表达式的索引。由 String.prototype.search()方法使用。</p></blockquote> <p>String.prototype.search() 方法会使用以 Symbol.search 为键的函数来对正则表达式求值</p> <h4 id="symbol-split"><a href="#symbol-split" class="header-anchor">#</a> Symbol.split</h4> <blockquote><p>这个符号作为一个属性表示：一个正则表达式方法，该方法在匹配正则表达式的索引位置拆分字符串。由 String.prototype.split()方法使用。</p></blockquote> <p>String.prototype. split()方法会使用以 Symbol.split 为键的函数来对正则表达式求值</p> <h4 id="symbol-species"><a href="#symbol-species" class="header-anchor">#</a> Symbol.species</h4> <blockquote><p>这个符号作为一个属性表示：一个函数值，该函数作为创建派生对象的构造函数。</p></blockquote> <p>这个属性在内置类型中最常用，用于对内置类型实例方法的返回值暴露实例化派生对象的方法。用 Symbol.species 定义静态的获取器(getter)方法，可以覆盖新创建实例的原型定义</p> <h4 id="symbol-toprimitive"><a href="#symbol-toprimitive" class="header-anchor">#</a> Symbol.toPrimitive</h4> <blockquote><p>这个符号作为一个属性表示：一个方法，该方法将对象转换为相应的原始值。由ToPrimitive 抽象操作使用。</p></blockquote> <p>很多内置操作都会尝试强制将对象转换为原始值，包括字符串、 数值和未指定的原始类型。</p> <h4 id="symbol-tostringtag"><a href="#symbol-tostringtag" class="header-anchor">#</a> Symbol.toStringTag</h4> <blockquote><p>这个符号作为一个属性表示：一个字符串，该字符串用于创建对象的默认字符串描述。由内置方法 Object.prototype.toString()使用。</p></blockquote> <p>通过 toString()方法获取对象标识时，会检索由 Symbol.toStringTag 指定的实例标识符，默认为&quot;Object&quot;。</p> <h4 id="symbol-unscopables"><a href="#symbol-unscopables" class="header-anchor">#</a> Symbol.unscopables</h4> <blockquote><p>这个符号作为一个属性表示：一个对象，该对象所有的以及继承的属性， 都会从关联对象的 with 环境绑定中排除。</p></blockquote> <p>设置这个符号并让其映射对应属性的键值为 true，就可以阻止该属性出现在 with 环境绑定中</p> <p><strong>不推荐使用witch，因此也不推荐使用Symbol.unscopables</strong></p> <h3 id="object-类型"><a href="#object-类型" class="header-anchor">#</a> Object 类型</h3> <p>ECMAScript 中的对象其实就是一组数据和功能的集合。ECMAScript 中的对象其实就是一组数据和功能的集合。</p> <p>Object 的实例本身并不是很有用，但理解与它相关的概念非常重要。ECMAScript 中的 Object 是派生其他对象的基类。Object 类型的所有属性和方法在派生的对象上同样存在。</p> <p>每个 Object 实例都有如下属性和方法。</p> <ul><li>constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是Object()函数。</li> <li>hasOwnProperty(propertyName)：用于判断当前对象实例(不是原型)上是否存在给定的属性。要检查的属性名必须是字符串(如 o.hasOwnProperty(&quot;name&quot;))或符号。</li> <li>isPrototypeOf(object)：用于判断当前对象是否为另一个对象的原型。</li> <li>propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用for-in 语句枚举。与 hasOwnProperty()一样，属性名必须是字符串。</li> <li>toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。</li> <li>toString()：返回对象的字符串表示。</li> <li>valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与 toString()的返回值相同。</li></ul> <blockquote><p>严格来讲，ECMA-262 中对象的行为不一定适合 JavaScript 中的其他对象。比如浏览器环境中的 BOM 和 DOM 对象，都是由宿主环境定义和提供的宿主对象。而宿主对象不受 ECMA-262 约束，所以它们可能会也可能不会继承 Object。</p></blockquote> <h2 id="操作符"><a href="#操作符" class="header-anchor">#</a> 操作符</h2> <blockquote><p>ECMA-262 描述了一组可用于操作数据值的操作符，包括数学操作符(如加、减)、位操作符、关系操作符和相等操作符等。ECMAScript 中的操作符是独特的，因为它们可用于各种值，包括字符串、数值、布尔值，甚至还有对象。在应用给对象时，操作符通常会调用 valueOf()和/或 toString()方法来取得可以计算的值。</p></blockquote> <h3 id="一元操作符"><a href="#一元操作符" class="header-anchor">#</a> 一元操作符</h3> <blockquote><p>只操作一个值的操作符叫一元操作符(unary operator)。</p></blockquote> <h4 id="递增-递减操作符"><a href="#递增-递减操作符" class="header-anchor">#</a> 递增/递减操作符</h4> <p>递增和递减操作符直接照搬自 C 语言，但有两个版本:前缀版和后缀版。顾名思义，前缀版就是位于要操作的变量前头，后缀版就是位于要操作的变量后头。</p> <p>后缀版与前缀版的主要区别在于，后缀版递增和递减在语句被求值后才发生。</p> <p>这 4 个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可 以。递增和递减操作符遵循如下规则。</p> <ul><li>对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值。</li> <li>对于字符串，如果不是有效的数值形式，则将变量的值设置为 NaN 。变量类型从字符串变成数值。</li> <li>对于布尔值，如果是 false，则转换为 0 再应用改变。变量类型从布尔值变成数值。</li> <li>对于布尔值，如果是 true，则转换为 1 再应用改变。变量类型从布尔值变成数值。</li> <li>对于浮点值，加 1 或减 1。</li> <li>如果是对象，则调用其valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是 NaN，则调用 toString()并再次应用其他则。变量类型从对象变成数值。</li></ul> <h4 id="一元加和减"><a href="#一元加和减" class="header-anchor">#</a> 一元加和减</h4> <p>一元加和减操作符对大多数开发者来说并不陌生，它们在 ECMAScript 中跟在高中数学中的用途一样。</p> <p>如果将一元加/减应用到非数值，则会执行与使用 Number()转型函数一样的类型转换:布尔值 false 和 true 转换为 0 和 1，字符串根据特殊规则进行解析，对象会调用它们的 valueOf()和/或 toString() 方法以得到可以转换的值。</p> <p>也可利用非数值的隐式转换规则用于数据类型转换。</p> <h3 id="位操作符"><a href="#位操作符" class="header-anchor">#</a> 位操作符</h3> <p>接下来要介绍的操作符用于数值的底层操作，也就是操作内存中表示数据的比特(位)。ECMAScript中的所有数值都以 IEEE 754 64 位格式存储，但位操作并不直接应用到 64 位表示，而是先把值转换为32位整数，再进行位操作，之后再把结果转换为 64 位。对开发者而言，就好像只有 32 位整数一样，因为 64 位整数存储格式是不可见的。既然知道了这些，就只需要考虑 32 位整数即可。</p> <p>有符号整数使用 32 位的前 31 位表示整数值。第 32 位表示数值的符号，如 0 表示正，1 表示负。这一位称为符号位(sign bit)，它的值决定了数值其余部分的格式。</p> <p>正值以真正的二进制格式存储，即 31位中的每一位都代表 2 的幂。</p> <p><img src="/assets/img/image-20210114101329611.6d3625b6.png" alt="image-20210114101329611"></p> <p>负值以一种称为二补数(或补码)的二进制编码存储。一个数值的二补数通过如下 3 个步骤计算得到:</p> <p>(1) 确定绝对值的二进制表示(如，对于-18，先确定 18 的二进制表示);</p> <p>(2) 找到数值的一补数(或反码)，换句话说，就是每个 0 都变成 1，每个 1 都变成 0;</p> <p>(3) 给结果加 1。</p> <p>那么，-18 的二进制表示就是 11111111111111111111111111101110。要注意的是，在处理有符号整数时，我们无法访问第 31 位。</p> <p>ECMAScript 会帮我们记录这些信息。在把负值输出为一个二进制字符串时，我们会得到一个前面加了减号的绝对值</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">18</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>num<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// &quot;-10010&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><blockquote><p>转换过程会求得二补数，然后再以<strong>更符合逻辑</strong>的形式表示出来。</p></blockquote> <p>默认情况下，ECMAScript 中的所有整数都表示为有符号数。不过，确实存在无符号整数。对无符号整数来说，第 32 位不表示符号，因为只有正值。无符号整数比有符号整数的范围更大，因为符号位被用来表示数值了。</p> <p>由于前面提及64位是不可见的，所以ECMAScript中的数值应用位操作符时，后台会发生转换：64位数值会转换为32位数值，然后执行位操作，最后再把结果从32位转换为64位存储起来。整个过程就像处理 32 位数值一样，这让二进制操作变得与其他语言中类似。但这个转换也导致了一个奇特的副作用，<strong>即特殊值 NaN 和 Infinity 在位操作中都会被当成 0 处理</strong>。</p> <h4 id="按位非"><a href="#按位非" class="header-anchor">#</a> 按位非</h4> <p>按位非操作符用波浪符(~)表示，它的作用是返回数值的一补数。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> num1 <span class="token operator">=</span> <span class="token number">25</span><span class="token punctuation">;</span> <span class="token comment">// 二进制00000000000000000000000000011001 let num2 = ~num1; // 二进制11111111111111111111111111100110 console.log(num2); // -26</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>按位非的最终效果是对 数值取反并减 1，但与一元操作符相比，位操作的速度快的多，因为位操作是在数值的底层表示上完成。</p> <h4 id="按位与"><a href="#按位与" class="header-anchor">#</a> 按位与</h4> <p>按位与操作符用和号(&amp;)表示，有两个操作数。按位与就是将两个数的每一个位对齐， 然后基于真值表中的规则，对每一位执行相应的与操作。</p> <h4 id="按位或"><a href="#按位或" class="header-anchor">#</a> 按位或</h4> <p>按位或操作符用管道符(|)表示，同样有两个操作数。按位或就是将两个数的每一个位对齐， 然后基于真值表中的规则，对每一位执行相应的或操作。</p> <h4 id="按位异或"><a href="#按位异或" class="header-anchor">#</a> 按位异或</h4> <p>按位异或用脱字符(^)表示，同样有两个操作数。按位异或与按位或的区别是，它只在一位上是 1 的时候返回 1(两位都是 1 或 0，则返回 0)。</p> <h4 id="左移"><a href="#左移" class="header-anchor">#</a> 左移</h4> <p>左移操作符用两个小于号(&lt;&lt;)表示，会按照指定的位数将数值的所有位向左移动。</p> <p>左移会保留它所操作数值的符号。</p> <h4 id="有符号右移"><a href="#有符号右移" class="header-anchor">#</a> 有符号右移</h4> <p>有符号右移由两个大于号(&gt;&gt;)表示，会将数值的所有 32 位都向右移，同时保留符号(正或负)。 有符号右移实际上是左移的逆运算。</p> <h4 id="无符号右移"><a href="#无符号右移" class="header-anchor">#</a> 无符号右移</h4> <p>无符号右移用 3 个大于号表示(&gt;&gt;&gt;)，会将数值的所有 32 位都向右移。对于正数，无符号右移与 有符号右移结果相同。</p> <p>对于负数，有时候差异会非常大。与有符号右移不同，无符号右移会给空位补 0，而不管符号位是什么。对正数来说，这跟有符号右移效果相同。但对负数来说，结果就差太多了。</p> <p>无符号右移操作符将负数的二进制表示当成正数的二进制表示来处理。因为负数是其绝对值的二补数，所以右移之后结果变 得非常之大，</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> oldValue <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">64</span><span class="token punctuation">;</span> <span class="token comment">// 等于二进制11111111111111111111111111000000</span>
<span class="token keyword">let</span> newValue <span class="token operator">=</span> oldValue <span class="token operator">&gt;&gt;&gt;</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 等于十进制 134217726</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="布尔操作符"><a href="#布尔操作符" class="header-anchor">#</a> 布尔操作符</h3> <h4 id="逻辑非"><a href="#逻辑非" class="header-anchor">#</a> 逻辑非</h4> <p>逻辑非操作符由一个叹号(!)表示，可应用给 ECMAScript 中的任何值。这个操作符始终返回布 尔值，无论应用到的是什么数据类型。逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。换 句话说，逻辑非操作符会遵循如下规则。</p> <table><thead><tr><th>操作数</th> <th>结果</th></tr></thead> <tbody><tr><td>Object</td> <td>alse</td></tr> <tr><td>&quot;&quot;</td> <td>true</td></tr> <tr><td>&quot;XXX&quot;</td> <td>false</td></tr> <tr><td>0</td> <td>true</td></tr> <tr><td>非0(包括Infinity)</td> <td>false</td></tr> <tr><td>null</td> <td>rue</td></tr> <tr><td>NaN</td> <td>true</td></tr> <tr><td>undefined</td> <td>true</td></tr></tbody></table> <p>逻辑非操作符也可以用于把任意值转换为布尔值。同时使用两个叹号(!!)，相当于调用了转型函数 Boolean()。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反，从而给出变量真正对应的布尔值。</p> <h4 id="逻辑与"><a href="#逻辑与" class="header-anchor">#</a> 逻辑与</h4> <p>逻辑与操作符由两个和号(&amp;&amp;)表示，应用到两个值。</p> <p>逻辑与操作符遵循真值表规则（这个就不用罗列了吧）</p> <ul><li>如果第一个操作数是对象，则返回第二个操作数。</li> <li>如果第二个操作数是对象，则只有第一个操作数求值为 true 才会返回该对象。</li> <li>如果两个操作数都是对象，则返回第二个操作数。</li> <li>如果有一个操作数是 null，则返回 null。</li> <li>如果有一个操作数是 NaN，则返回 NaN。</li> <li>如果有一个操作数是 undefined，则返回 undefined。</li></ul> <p>逻辑与操作符是一种短路操作符，意思就是如果第一个操作数决定了结果，那么永远不会对第二个操作数求值。对逻辑与操作符来说，如果第一个操作数是 false，那么无论第二个操作数是什么值，结果也不可能等于 true。</p> <h4 id="逻辑或"><a href="#逻辑或" class="header-anchor">#</a> 逻辑或</h4> <p>逻辑或操作符由两个管道符(||)表示。</p> <p>逻辑或操作符遵循真值表规则（这个就不用罗列了吧）</p> <ul><li>如果第一个操作数是对象，则返回第一个操作数。</li> <li>如果第一个操作数求值为 false，则返回第二个操作数。</li> <li>如果两个操作数都是对象，则返回第一个操作数。</li> <li>如果两个操作数都是 null，则返回 null。</li> <li>如果两个操作数都是 NaN，则返回 NaN。</li> <li>如果两个操作数都是 undefined，则返回 undefined。</li></ul> <p>同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，第一个操作数求值为true，第二个操作数就不会再被求值了。</p> <h3 id="乘性操作符"><a href="#乘性操作符" class="header-anchor">#</a> 乘性操作符</h3> <blockquote><p>ECMAScript 定义了 3 个乘性操作符:乘法、除法和取模。这些操作符跟它们在 Java、C 语言及 Perl 中对应的操作符作用一样，但在处理非数值时，它们也会包含一些自动的类型转换。如果乘性操作符有不是数值的操作数，则该操作数会在后台被使用 Number()转型函数转换为数值。这意味着空字符串会被当成 0，而布尔值 true 会被当成 1。</p></blockquote> <h4 id="乘法操作符"><a href="#乘法操作符" class="header-anchor">#</a> 乘法操作符</h4> <p>乘法操作符由一个星号(*)表示，可以用于计算两个数值的乘积。</p> <p>特殊行为：</p> <ul><li>如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正值，正负符号不同的值相乘得到负值。如果 ECMAScript 不能表示乘积，则返回 Infinity 或-Infinity。</li> <li>如果有任一操作数是 NaN，则返回 NaN。</li> <li>如果是 Infinity 乘以 0，则返回 NaN。</li> <li>如果是 Infinity 乘以非 0 的有限数值，则根据第二个操作数的符号返回 Infinity 或-Infinity。</li> <li>如果是 Infinity 乘以 Infinity，则返回 Infinity。</li> <li>如果有不是数值的操作数，则先在后台用 Number()将其转换为数值，然后再应用上述规则。</li></ul> <h4 id="除法操作符"><a href="#除法操作符" class="header-anchor">#</a> 除法操作符</h4> <p>除法操作符由一个斜杠(/)表示，用于计算第一个操作数除以第二个操作数的商。</p> <p>特殊行为：</p> <ul><li>如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正值，符号不同的值相除得到负值。如果 ECMAScript 不能表示商，则返回 Infinity 或-Infinity。</li> <li>如果有任一操作数是 NaN，则返回 NaN。</li> <li>如果是 Infinity 除以 Infinity，则返回 NaN。</li> <li>如果是 0 除以 0，则返回 NaN。</li> <li>如果是 Infinity 除以任何数值，则根据第二个操作数的符号返回 Infinity 或-Infinity。</li> <li>如果是非 0 的有限值除以 0，则根据第一个操作数的符号返回 Infinity 或-Infinity。</li> <li>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。</li></ul> <h4 id="取模操作符"><a href="#取模操作符" class="header-anchor">#</a> 取模操作符</h4> <p>取模(余数)操作符由一个百分比符号(%)表示。</p> <p>特殊行为：</p> <ul><li>如果操作数是数值，则执行常规除法运算，返回余数。</li> <li>如果被除数是无限值，除数是有限值，则返回 NaN。</li> <li>如果被除数是有限值，除数是 0，则返回 NaN。</li> <li>如果被除数是 0，除数不是 0，则返回 0。</li> <li>如果是 Infinity 除以 Infinity，则返回 NaN。</li> <li>如果被除数是有限值，除数是无限值，则返回被除数。</li> <li>如果有不是数值的操作数，则先在后台用 Number()函数将其转换为数值，然后再应用上述规则。</li></ul> <h3 id="指数操作符"><a href="#指数操作符" class="header-anchor">#</a> 指数操作符</h3> <p>ECMAScript 7 新增了指数操作符，Math.pow()现在有了自己的操作符**。</p> <p>指数操作符也有自己的指数赋值操作符**=，该操作符执行指数运算和结果的赋值操作。</p> <h3 id="加性操作符"><a href="#加性操作符" class="header-anchor">#</a> 加性操作符</h3> <blockquote><p>加性操作符，即加法和减法操作符，一般都是编程语言中最简单的操作符。不过，在 ECMAScript 中，这两个操作符拥有一些特殊的行为。与乘性操作符类似，加性操作符在后台会发生不同数据类型的转换。只不过对这两个操作符来说，转换规则不是那么直观。</p></blockquote> <h4 id="加法操作符"><a href="#加法操作符" class="header-anchor">#</a> 加法操作符</h4> <p>加法操作符(+)用于求两个数的和。</p> <p>操作数是数值下运算情况：</p> <ul><li>如果有任一操作数是 NaN，则返回 NaN;</li> <li>如果是 Infinity 加 Infinity，则返回 Infinity;</li> <li>如果是-Infinity 加-Infinity，则返回-Infinity;</li> <li>如果是 Infinity 加-Infinity，则返回 NaN;</li> <li>如果是+0 加+0，则返回+0;</li> <li>如果是-0 加+0，则返回+0;</li> <li>如果是-0 加-0，则返回-0。</li></ul> <p>如果有一个操作数是字符：</p> <ul><li>如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面;</li> <li>如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。</li></ul> <p>如果有任一操作数是对象、数值或布尔值，则调用它们的 toString()方法以获取字符串，然后再应用前面的关于字符串的规则。</p> <p>对于 undefined 和 null，则调用 String()函数，分别获取 &quot;undefined&quot;和&quot;null&quot;。</p> <h4 id="减法操作符"><a href="#减法操作符" class="header-anchor">#</a> 减法操作符</h4> <p>减法操作符(-)也是使用很频繁的一种操作符。</p> <p>运算规则：</p> <ul><li>如果两个操作数都是数值，则执行数学减法运算并返回结果。</li> <li>如果有任一操作数是 NaN，则返回 NaN。</li> <li>如果是 Infinity 减 Infinity，则返回 NaN。</li> <li>如果是-Infinity 减-Infinity，则返回 NaN。</li> <li>如果是 Infinity 减-Infinity，则返回 Infinity。</li> <li>如果是-Infinity 减 Infinity，则返回-Infinity。</li> <li>如果是+0 减+0，则返回+0。</li> <li>如果是+0 减-0，则返回-0。</li> <li>如果是-0 减-0，则返回+0。</li> <li>如果有任一操作数是字符串、布尔值、null 或 undefined，则先在后台使用 Number()将其转换为数值，然后再根据前面的规则执行数学运算。如果转换结果是 NaN，则减法计算的结果是NaN。</li> <li>如果有任一操作数是对象，则调用其 valueOf()方法取得表示它的数值。如果该值是 NaN，则减法计算的结果是 NaN。如果对象没有 valueOf()方法，则调用其 toString()方法，然后再将得到的字符串转换为数值。</li></ul> <h3 id="关系操作符"><a href="#关系操作符" class="header-anchor">#</a> 关系操作符</h3> <blockquote><p>关系操作符执行比较两个值的操作，包括小于(&lt;)、大于(&gt;)、小于等于(&lt;=)和大于等于(&gt;=)，用法跟数学课上学的一样。</p></blockquote> <p>转换规则：</p> <ul><li>如果操作数都是数值，则执行数值比较。</li> <li>如果操作数都是字符串，则逐个比较字符串中对应字符的编码。</li> <li>如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。</li> <li>如果有任一操作数是对象，则调用其 valueOf()方法，取得结果后再根据前面的规则执行比较。如果没有 valueOf()操作符，则调用 toString()方法，取得结果后再根据前面的规则执行比较。</li> <li>如果有任一操作数是布尔值，则将其转换为数值再执行比较。</li></ul> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> result <span class="token operator">=</span> <span class="token string">&quot;a&quot;</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// 因为&quot;a&quot;会转换为NaN，所以结果是false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>因为字符&quot;a&quot;不能转换成任何有意义的数值，所以只能转换为 NaN。这里有一个规则，即<strong>任何关系操作符在涉及比较 NaN 时都返回 false</strong>。</p> <div class="language-JavaScript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> result1 <span class="token operator">=</span> <span class="token number">NaN</span> <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span>  <span class="token comment">// false</span>
<span class="token keyword">let</span> result2 <span class="token operator">=</span> <span class="token number">NaN</span> <span class="token operator">&gt;=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token comment">// false</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>在大多数比较的场景中，如果一个值不小于另一个值，那就一定大于或等于它。</p> <p>但在比较 NaN 时，无论是小于还是大于等于，比较的结果都会返回 false。</p> <h3 id="相等操作符"><a href="#相等操作符" class="header-anchor">#</a> 相等操作符</h3> <blockquote><p>判断两个变量是否相等是编程中最重要的操作之一。在比较字符串、数值和布尔值是否相等时，过程都很直观。但是在比较两个对象是否相等时，情形就比较复杂了。</p> <p>ECMAScript 中的相等和不相等操作符，原本在比较之前会执行类型转换，但很快就有人质疑这种转换是否应该发生。</p> <p>最终，ECMAScript提供了两组操作符。第一组是等于和不等于，它们在比较之前执行转换。第二组是全等和不全等，它们在比较之前不执行转换。</p></blockquote> <h4 id="等于和不等于"><a href="#等于和不等于" class="header-anchor">#</a> 等于和不等于</h4> <blockquote><p>ECMAScript 中的等于操作符用两个等于号(==)表示，如果操作数相等，则会返回 true。</p> <p>不等于操作符用叹号和等于号(!=)表示，如果两个操作数不相等，则会返回 true。</p> <p>这两个操作符都会先进行**类型转换(通常称为强制类型转换)**再确定操作数是否相等。</p></blockquote> <p>转换规则：</p> <ul><li>如果任一操作数是布尔值，则将其转换为数值再比较是否相等。false 转换为 0，true 转换为 1。</li> <li>如果一个操作数是字符串，另一个操作数是数值，则尝试将字符串转换为数值，再比较是否相等。</li> <li>如果一个操作数是对象，另一个操作数不是，则调用对象的 valueOf()方法取得其原始值，再根据前面的规则进行比较。</li></ul> <p>在进行比较时，这两个操作符会遵循如下规则。</p> <ul><li>null 和 undefined 相等。</li> <li>null 和 undefined 不能转换为其他类型的值再进行比较。</li> <li>如果有任一操作数是 NaN，则相等操作符返回 false，不相等操作符返回 true。记住：即使两个操作数都是NaN，相等操作符也返回false，因为按照规则，NaN不等于NaN。</li> <li>如果两个操作数都是对象，则比较它们是不是同一个对象。如果两个操作数都指向同一个对象，则相等操作符返回true。否则，两者不相等。</li></ul> <p>特殊情况比较结果</p> <table><thead><tr><th>表达式</th> <th>结果</th></tr></thead> <tbody><tr><td>null == undefined</td> <td>true</td></tr> <tr><td>&quot;NaN&quot; == NaN</td> <td>false</td></tr> <tr><td>5 == NaN</td> <td>false</td></tr> <tr><td>NaN == NaN</td> <td>false</td></tr> <tr><td>NaN != NaN</td> <td>true</td></tr> <tr><td>false == 0</td> <td>true</td></tr> <tr><td>true == 1</td> <td>true</td></tr> <tr><td>true == 2</td> <td>false</td></tr> <tr><td>ndefined == 0</td> <td>false</td></tr> <tr><td>null == 0</td> <td>false</td></tr> <tr><td>&quot;5&quot; == 5</td> <td>true</td></tr></tbody></table> <h4 id="全等和不全等"><a href="#全等和不全等" class="header-anchor">#</a> 全等和不全等</h4> <blockquote><p>全等和不全等操作符与相等和不相等操作符类似，只不过它们在比较相等时不转换操作数。全等操作符由 3 个等于号(===)表示，只有两个操作数在不转换的前提下相等才返回 true。</p></blockquote> <p>由于相等和不相等操作符存在类型转换问题，因此推荐使用全等和不全等操作符。这样有助于在代码中保持数据类型的完整性。</p> <h3 id="条件操作符"><a href="#条件操作符" class="header-anchor">#</a> 条件操作符</h3> <p>三目运算符（无特殊场景）</p> <h3 id="赋值操作符"><a href="#赋值操作符" class="header-anchor">#</a> 赋值操作符</h3> <p>简单赋值用等于号(=)表示，将右手边的值赋给左手边的变量。</p> <p>复合赋值使用乘性、加性或位操作符后跟等于号(=)表示。</p> <ul><li>乘后赋值(*=)</li> <li>除后赋值(/=)</li> <li>取模后赋值(%=)</li> <li>加后赋值(+=)</li> <li>减后赋值(-=)</li> <li>左移后赋值(&lt;&lt;=)</li> <li>右移后赋值(&gt;&gt;=)</li> <li>无符号右移后赋值(&gt;&gt;&gt;=)</li></ul> <blockquote><p>这些操作符仅仅是简写语法，使用它们不会提升性能。</p></blockquote> <h3 id="逗号操作符"><a href="#逗号操作符" class="header-anchor">#</a> 逗号操作符</h3> <p>逗号操作符可以用来在一条语句中执行多个操作。</p> <div class="language-javascript line-numbers-mode"><pre class="language-javascript"><code><span class="token keyword">let</span> num1 <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> num2 <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">,</span> num3 <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token comment">// 在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助赋值。在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值:</span>
<span class="token keyword">let</span> num <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// num的值为0</span>
<span class="token comment">// 在这个例子中，num 将被赋值为 0，因为 0 是表达式中最后一项。逗号操作符的这种使用场景并不多见，但这种行为的确存在。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="语句-2"><a href="#语句-2" class="header-anchor">#</a> 语句</h2> <blockquote><p>ECMA-262 描述了一些语句(也称为流控制语句)，而 ECMAScript 中的大部分语法都体现在语句中。语句通常使用一或多个关键字完成既定的任务。</p> <p>语句可以简单，也可以复杂。简单的如告诉函数退出，复杂的如列出一堆要重复执行的指令。</p></blockquote> <h3 id="if语句"><a href="#if语句" class="header-anchor">#</a> if语句</h3> <h3 id="do-while语句"><a href="#do-while语句" class="header-anchor">#</a> do-while语句</h3> <h3 id="while语句"><a href="#while语句" class="header-anchor">#</a> while语句</h3> <h3 id="for语句"><a href="#for语句" class="header-anchor">#</a> for语句</h3> <h3 id="for-in语句"><a href="#for-in语句" class="header-anchor">#</a> for-in语句</h3> <h3 id="for-of语句"><a href="#for-of语句" class="header-anchor">#</a> for-of语句</h3> <h3 id="标签语句"><a href="#标签语句" class="header-anchor">#</a> 标签语句</h3> <h3 id="break和continue语句"><a href="#break和continue语句" class="header-anchor">#</a> break和continue语句</h3> <h3 id="with语句"><a href="#with语句" class="header-anchor">#</a> with语句</h3> <h3 id="switch语句"><a href="#switch语句" class="header-anchor">#</a> switch语句</h3> <h2 id="函数"><a href="#函数" class="header-anchor">#</a> 函数</h2> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">Last Updated:</span> <span class="time">1/13/2021, 6:52:25 PM</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/assets/js/app.9454abc9.js" defer></script><script src="/assets/js/2.62a85667.js" defer></script><script src="/assets/js/11.4f7dc882.js" defer></script>
  </body>
</html>
